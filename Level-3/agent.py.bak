"""LiteLLM Agent implementation for L2 Wizard."""

import json
from typing import List, Dict, Any, Optional
from openai import OpenAI
from config import AgentConfig
from tools import ToolRegistry


class LiteLLMAgent:
    """
    Production-ready agent using LiteLLM proxy with structured tool calling.
    
    This agent implements a clean agent loop pattern:
    1. Send user message + tool definitions to LiteLLM
    2. Model responds with either tool calls or final answer
    3. Execute tool calls and add results to conversation
    4. Loop until model provides final answer
    """
    
    def __init__(self, api_key: Optional[str] = None, verbose: bool = True):
        """
        Initialize the LiteLLM Agent.
        
        Args:
            api_key: DeepInfra API key (defaults to config)
            verbose: Whether to print step-by-step progress
        """
        self.api_key = api_key or AgentConfig.DEEPINFRA_API_KEY
        if not self.api_key:
            raise ValueError("DEEPINFRA_API_KEY is required")
        
        # Initialize OpenAI client pointing to LiteLLM proxy
        self.client = OpenAI(
            api_key=self.api_key,
            base_url=AgentConfig.LITELLM_BASE_URL
        )
        self.verbose = verbose
        self.tool_registry = ToolRegistry()
        self.tool_definitions = self.tool_registry.get_tool_definitions_openai_format()
        
        # System prompt defines agent behavior
        self.system_prompt = """You are a helpful AI assistant that can help users with various tasks.
You have access to several tools for getting information:
- Weather information for any location
- Book recommendations by topic
- Random jokes for entertainment
- Random dog pictures
- Trivia questions

When a user asks for help, determine which tools are needed and call them.
Always provide friendly, conversational responses that incorporate the tool results naturally.
If coordinates are mentioned, use them for weather. Parse requests carefully to identify all needed tools."""
    
    def run(self, user_message: str, max_iterations: Optional[int] = None) -> str:
        """
        Run the agent loop for a single user message.
        
        Args:
            user_message: The user's input message
            max_iterations: Maximum number of agent loop iterations (defaults to config)
            
        Returns:
            Final agent response as a string
        """
        max_iterations = max_iterations or AgentConfig.MAX_ITERATIONS
        
        # Initialize conversation with user message
        messages = [
            {
                "role": "user",
                "content": user_message
            }
        ]
        
        if self.verbose:
            print(f"\nğŸ¤– Processing: {user_message}\n")
        
        iteration = 0
        while iteration < max_iterations:
            iteration += 1
            
            if self.verbose:
                print(f"[Iteration {iteration}]")
            
            # Call Claude with current conversation state
            response = self.client.messages.create(
                model=AgentConfig.MODEL_NAME,
                max_tokens=AgentConfig.MAX_TOKENS,
                temperature=AgentConfig.TEMPERATURE,
                system=self.system_prompt,
                messages=messages,
                tools=self.tool_definitions
            )
            
            # Check stop reason
            if response.stop_reason == "end_turn":
                # Claude provided final answer without tool use
                final_text = self._extract_text_from_content(response.content)
                if self.verbose:
                    print("âœ“ Final answer provided\n")
                return final_text
            
            elif response.stop_reason == "tool_use":
                # Claude wants to use tools
                if self.verbose:
                    print("ğŸ“‹ Claude requested tool calls")
                
                # Add Claude's response to messages
                messages.append({
                    "role": "assistant",
                    "content": response.content
                })
                
                # Execute all requested tools
                tool_results = []
                for content_block in response.content:
                    if content_block.type == "tool_use":
                        tool_name = content_block.name
                        tool_input = content_block.input
                        tool_use_id = content_block.id
                        
                        if self.verbose:
                            print(f"  â†’ Calling {tool_name} with {tool_input}")
                        
                        # Execute tool
                        try:
                            result = self.tool_registry.execute_tool(tool_name, tool_input)
                            if self.verbose:
                                print(f"    âœ“ Success")
                        except Exception as e:
                            result = {"error": str(e)}
                            if self.verbose:
                                print(f"    âœ— Error: {e}")
                        
                        # Add tool result to results list
                        tool_results.append({
                            "type": "tool_result",
                            "tool_use_id": tool_use_id,
                            "content": json.dumps(result)
                        })
                
                # Add tool results to conversation
                messages.append({
                    "role": "user",
                    "content": tool_results
                })
                
                if self.verbose:
                    print()
                
            elif response.stop_reason == "max_tokens":
                if self.verbose:
                    print("âš  Response truncated (max tokens)\n")
                return self._extract_text_from_content(response.content) + "\n\n[Response truncated]"
            
            else:
                # Unexpected stop reason
                if self.verbose:
                    print(f"âš  Unexpected stop reason: {response.stop_reason}\n")
                return self._extract_text_from_content(response.content)
        
        # Max iterations reached
        if self.verbose:
            print(f"âš  Max iterations ({max_iterations}) reached\n")
        return "I apologize, but I couldn't complete your request within the iteration limit."
    
    def _extract_text_from_content(self, content: List[Any]) -> str:
        """Extract text from Claude's content blocks."""
        text_parts = []
        for block in content:
            if hasattr(block, 'type') and block.type == "text":
                text_parts.append(block.text)
        return "\n".join(text_parts)
    
    def interactive_mode(self):
        """Run the agent in interactive mode for testing."""
        print("=" * 60)
        print("L2 Wizard - Claude Agent (Level 3)")
        print("=" * 60)
        print("\nAvailable capabilities:")
        print("  ğŸŒ¤ï¸  Weather information (provide coordinates)")
        print("  ğŸ“š Book recommendations")
        print("  ğŸ˜„ Random jokes")
        print("  ğŸ• Dog pictures")
        print("  ğŸ¯ Trivia questions")
        print("\nType 'exit' or 'quit' to stop.\n")
        
        while True:
            try:
                user_input = input("ğŸ”· You: ").strip()
                
                if not user_input:
                    continue
                
                if user_input.lower() in {"exit", "quit", "q"}:
                    print("\nğŸ‘‹ Goodbye!\n")
                    break
                
                response = self.run(user_input)
                print(f"\nğŸ¯ Agent: {response}\n")
                print("-" * 60)
                
            except KeyboardInterrupt:
                print("\n\nğŸ‘‹ Goodbye!\n")
                break
            except Exception as e:
                print(f"\nâŒ Error: {e}\n")
                if self.verbose:
                    import traceback
                    traceback.print_exc()


def main():
    """Main entry point for the agent."""
    try:
        # Validate configuration
        AgentConfig.validate()
        
        # Create and run agent
        agent = ClaudeAgent(verbose=AgentConfig.VERBOSE)
        agent.interactive_mode()
        
    except ValueError as e:
        print(f"\nâŒ Configuration Error: {e}\n")
        print("Please set the ANTHROPIC_API_KEY environment variable:")
        print("  export ANTHROPIC_API_KEY='your-key-here'")
        print()
        return 1
    except Exception as e:
        print(f"\nâŒ Unexpected Error: {e}\n")
        import traceback
        traceback.print_exc()
        return 1
    
    return 0


if __name__ == "__main__":
    import sys
    sys.exit(main())
